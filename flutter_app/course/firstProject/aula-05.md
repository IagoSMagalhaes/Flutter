

models -> colocar código para modelos;
screens -> Widgets que representam uma tela inteira;
components -> Widgets que representam componentes menores reutilizáveis.




Parabéns por ter concluído o curso Fundamentos de Flutter! Agora você é capaz de criar um aplicativo do zero utilizando essa ferramenta bastante útil e que facilita muito a construção dos nossos projetos, entregando um visual interessante para o usuário. Aproveitando esse momento de conclusão, vamos rever os conceitos que foram trabalhados ao longo desse treinamento.

No início, conhecemos o Flutter e ganhamos acesso à ele por meio do Prompt de Comando/Terminal, por onde conseguimos criar um projeto e verificar a instalação de dependências. Em seguida, aprendemos que existem diferentes editores que nos permitem trabalhar com o código, com o IntelliJ, e o Visual Studio Code. O IntelliJ, que utilizamos ao longo do curso, é uma IDE bastante poderosa e nos forneceu diversas features que facilitaram o desenvolvimento do projeto.

Avançando, descobrimos que a base de funcionamento do Flutter são os widgets, que representam os elementos visuais do aplicativo e são comuns em qualquer tipo de tela ou funcionalidade. Para construirmos uma tela com diversos widgets, usamos uma estrutura hierárquica de árvore.

A princípio trabalhamos bastante com o catálogo de widgets do Material components, componentes que atendem ao Material design (uma série de orientações visuais para desenvolvimento de aplicativos Android) e que acessamos pela documentação do próprio Flutter. Nesse ponto, também aprendemos que a proposta do Flutter não é exatamente criar componentes do zero, mas sim utilizar componentes já prontos de modo a reduzir ao máximo o tempo de desenvolvimento do aplicativo.

Foi pensando nisso que implementamos componentes como a AppBar(), Card(), ListTile() eFloatingActionButton(), TextField() e RaisedButton(), que nos auxiliaram a montar os layouts das nossas telas, a navegar entre elas, a inserir e atualizar dados e assim por diante.

Conhecemos dois tipos de widgets e aprendemos a principal diferença entre eles: quando é necessário fazer alterações dinãmicas, precisamos utilizar um StatefulWidget; já quando isso não é necessário, por exemplo durante os testes no desenvolvimento, é recomendada a utilização de um StatelessWidget e de variáveis do tipo final de modo a tornarmos nosso código mais seguro e consistente.

Também aprendemos que no Flutter temos uma abordagem diferente para a construção de layouts em relação a outras plataformas, nas quais costuma-se criar um arquivo específico em linguagens como HTML ou XML. No Flutter, isso é feito de modo mais declarativo, com uma classe que representa o nosso próprio widget onde fazemos a configuração do nosso código fonte.

Ao longo da criação do aplicativo, conhecemos várias técnicas de refatoração visando tornar o nosso código mais legível e melhorar a sua manutenção, como a extração de widgets e funções, a flexibilização e reutilização de widgets e a organização do projeto em diferentes pacotes.

Esperamos que você tenha gostado do conteúdo e se sinta motivado(a) a criar seus próprios aplicativos usando o Flutter! Bons estudos e até a próxima!






#Nesta aula, aprendemos:
Nesta aula, aprendemos:

Implementar StatefulWidgets;
Evitar bugs comuns na implementação de fluxo de tela e formulário;
Ajustar o tema do App com as cores do Color Tool;
Organizar a estrutura do projeto.